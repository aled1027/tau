{
  "id": "49fb8723",
  "title": "Persistence & Threads: Implementation Complete",
  "tags": [
    "plan",
    "persistence"
  ],
  "status": "done",
  "created_at": "2026-02-12T18:07:52.591Z"
}

# Persistence & Thread Management Plan

## Goal
Allow sessions to be resumed across page reloads by persisting agent state (conversation + virtual filesystem) to browser storage. Support multiple threads (like `/new` in pi).

## Storage Strategy

| Data | Storage | Rationale |
|------|---------|-----------|
| Thread list metadata (id, name, created, lastUsed) | **localStorage** | Small, fast, synchronous reads for sidebar rendering |
| Active thread ID | **localStorage** | Tiny, needs fast access |
| API key | **localStorage** | Already done |
| Conversation messages per thread | **IndexedDB** | Can be large (many KB–MB), structured data |
| VirtualFS files per thread | **IndexedDB** | Can be large, binary-safe |

## New Modules

### 1. `src/core/storage.ts` — Low-level persistence layer
- `ThreadStorage` class wrapping IndexedDB via a thin helper (no external deps)
- IndexedDB database: `pi-browser`
- Object stores:
  - `threads` — keyed by threadId, stores `{ id, name, createdAt, updatedAt }`
  - `messages` — keyed by threadId, stores `Message[]` array
  - `fs` — keyed by `${threadId}:${path}`, stores file contents
- Methods:
  - `saveThread(meta)` / `getThread(id)` / `listThreads()` / `deleteThread(id)`
  - `saveMessages(threadId, messages)` / `getMessages(threadId)`
  - `saveFile(threadId, path, content)` / `getFiles(threadId)` / `deleteFiles(threadId)`
  - `saveFS(threadId, files: Map<string,string>)` — bulk save all files for a thread

### 2. `src/core/thread-manager.ts` — Thread lifecycle management
- `ThreadManager` class
- Manages creating, switching, listing, deleting threads
- Methods:
  - `createThread(name?)` → threadId — creates new thread, sets as active
  - `switchThread(threadId)` → loads messages + FS from IndexedDB, returns hydrated Agent (or data for one)
  - `listThreads()` → thread metadata array sorted by lastUsed
  - `deleteThread(threadId)`
  - `getActiveThreadId()` / `setActiveThreadId(id)` — backed by localStorage
  - `persistCurrentState(agent)` — saves messages + FS to IndexedDB for active thread
- Emits events or returns data; doesn't own the Agent directly

## Changes to Existing Modules

### 3. `Agent` changes (`src/core/agent.ts`)
- Add `Agent.serialize()` → `{ messages: Message[], fs: Record<string, string> }`
- Add static `Agent.deserialize(config, data)` or accept `initialMessages` + `initialFS` in `AgentConfig`
- Add `AgentConfig.initialMessages?: Message[]` and `AgentConfig.initialFS?: Record<string, string>`
- Constructor uses these to hydrate instead of starting fresh
- After each `prompt()` completes, emit a `"state_changed"` event (or call a persist callback) so the UI layer can trigger a save

### 4. `VirtualFS` changes (`src/core/tools.ts`)
- Add `VirtualFS.snapshot(): Map<string, string>` — returns a copy of all files
- Add `VirtualFS.restore(files: Map<string, string>)` — replaces all files
- Add `VirtualFS.toJSON()` / `VirtualFS.fromJSON()` for serialization convenience

### 5. Exports (`src/core/index.ts`)
- Export `ThreadStorage`, `ThreadManager`, and new types

## UI Integration (example chat app)

### 6. `app-root.ts` changes
- On start, initialize `ThreadManager` + `ThreadStorage`
- Check for active thread; if exists, restore it instead of starting blank
- Pass thread info to chat-view

### 7. `chat-view.ts` changes
- Add a `/new` command (or button) that creates a new thread via ThreadManager
- Add thread sidebar or dropdown to switch threads
- After each assistant turn completes, call `threadManager.persistCurrentState(agent)`
- On thread switch: save current, load new, re-render messages

## Auto-save Strategy
- Save after each completed assistant turn (after `prompt()` finishes)
- Save FS in bulk (snapshot entire VirtualFS) — simpler than tracking individual writes
- Debounce if needed, but turn-level granularity is likely fine

## Thread Naming
- Default name: first user message truncated to 50 chars
- Could add LLM-generated names later (out of scope for now)

## Implementation Order
1. `VirtualFS` snapshot/restore methods
2. `storage.ts` — IndexedDB layer
3. `Agent` hydration support (initialMessages, initialFS)
4. `thread-manager.ts`
5. Update exports
6. Update chat example UI (thread switching, auto-persist)
7. Test: create thread → chat → reload → verify state restored
